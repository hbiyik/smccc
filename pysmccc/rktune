#!/usr/bin/python
"""
 Copyright (C) 2024 boogie

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import argparse
import os
import sys
import logging

from smccc import common
from smccc.sip.rockchip import dmc
from smccc.sip.rockchip import model as rksipmodel

from scmi.transports import smc
from scmi.protocols import clock
from scmi.protocols import base
from scmi import model as scmimodel


SCMI_CLOCKS = {"rk3528_cpu": 21,
               "rk3528_gpu": 22,
               "rk3588_cpul": 0,
               "rk3588_cpub0": 2,
               "rk3588_cpub1": 3,
               "rk3588_gpu": 5,
               "rk3588_npu": 6}


def clock_type(s):
    try:
        return SCMI_CLOCKS[s.lower()]
    except Exception:
        try:
            intval = int(s)
            if intval < 0:
                raise ValueError
            return intval
        except Exception:
            raise argparse.ArgumentTypeError(f"{s} is not a valid clock id")


REMOTE_DBG = "192.168.2.10"
REMOTE_DBG = None

if REMOTE_DBG:
    import pydevd  # @UnresolvedImport
    pydevd.settrace(REMOTE_DBG, stdoutToServer=True, stderrToServer=True, suspend=False)

parser = argparse.ArgumentParser(prog="rktune")
parser.add_argument("--debug", "-d", action='store_true', help="enable debug logging")
subparsers = parser.add_subparsers(help="command", dest="command", required=True)


parser_mem = subparsers.add_parser('mem', help="memory tuning")
subparsers_mem = parser_mem.add_subparsers(help="sub command", dest="subcommand", required=True)

parser_mem_getclocks = subparsers_mem.add_parser('getclocks', help="get trained clocks")

parser_mem_setclock = subparsers_mem.add_parser('setclock', help="set current dram clock")
parser_mem_setclock.add_argument("index", type=int, help="clock index as provided in getclocks")
parser_mem_setclock.add_argument("clock", type=int, help="clock value in Mhz")

parser_mem_setclock = subparsers_mem.add_parser('applyclock', help="set current dram clock")
parser_mem_setclock.add_argument("index", type=int, help="clock index as provided in get/setclocks")


parser_scmi = subparsers.add_parser('scmi', help="scmi interface")
parser_scmi.add_argument("--agent", "-a", type=int, default=int(rksipmodel.RkSipCommand.SCMI_AGENT0), help="agent smc sip id")
parser_scmi.add_argument("--sram", "-s", type=int, default=0x10f000, help="sram physcal address")
parser_scmi.add_argument("--length", "-l", type=int, default=0x100, help="sram physcal address size in bytes")

subparsers_scmi = parser_scmi.add_subparsers(help="protocol", dest="protocol", required=True)
parser_scmi_clock = subparsers_scmi.add_parser('list', help="List available protocols")

parser_scmi_clock = subparsers_scmi.add_parser('clock', help=str(scmimodel.Protocols.CLOCK_MANAGEMENT))
subparsers_scmi_clock = parser_scmi_clock.add_subparsers(help="sub command", dest="subcommand", required=True)

parser_scmi_clock_getrates = subparsers_scmi_clock.add_parser('getrates', help="get available clocks")
parser_scmi_clock_getrates.add_argument("clock_id", type=clock_type, help="numeric clock id")

parser_scmi_clock_getrate = subparsers_scmi_clock.add_parser('getrate', help="get clock")
parser_scmi_clock_getrate.add_argument("clock_id", type=clock_type, help="numeric clock id")

parser_scmi_clock_setrate = subparsers_scmi_clock.add_parser('setrate', help="set clock in Mhz")
parser_scmi_clock_setrate.add_argument("clock_id", type=clock_type, help="numeric clock id")
parser_scmi_clock_setrate.add_argument("freq", type=clock_type, help="frequency in Mhz")

args = parser.parse_args()

if not os.path.exists(common.PROCPATH):
    common.logger.error(f"{common.PROCPATH} device does not exists. Please load the kernel module with 'insmod smccc.ko'")
    sys.exit(-1)

if not os.access(common.PROCPATH, os.R_OK):
    common.logger.error(f"{common.PROCPATH} device is not readable. Run as root or give proper permissions to {common.PROCPATH}")
    sys.exit(-2)

if not os.access(common.PROCPATH, os.W_OK):
    common.logger.error(f"{common.PROCPATH} device is not writable. Run as root or give proper permissions to {common.PROCPATH}")
    sys.exit(-3)


def check_dram_clock_index(dram, index):
    clocks = dram.getclocks()
    if index >= len(clocks) or index < 0:
        common.logger.error(f"Clock index must be in between 0-{len(clocks) - 1}, {index} provided")
        sys.exit(-1)
    return clocks


if args.debug:
    common.setloglevel(logging.DEBUG)
if args.command == "mem":
    with dmc.Dram() as dram:
        if args.subcommand == "getclocks":
            for i, clock in enumerate(dram.getclocks()):
                common.logger.info(f"{i}) {clock}Mhz")

        if args.subcommand == "setclock":
            check_dram_clock_index(dram, args.index)
            dram.setclock(args.index, args.clock)
            common.logger.info(f"Dram clock {args.index} is set to {args.clock}Mhz")

        if args.subcommand == "applyclock":
            clocks = check_dram_clock_index(dram, args.index)
            resp = dram.applyclock(args.index)
            if(not resp):
                common.logger.info(f"Dram clock is set to {clocks[args.index]}Mhz")
            else:
                common.logger.info(f"Can not set dram clock")
                sys.exit(resp)

if args.command == "scmi":
    t = smc.Smc(args.agent, args.sram, args.length)
    if args.protocol == "list":
        p = base.Base(t)
        for prot in p.discover_list_protocols(0):
            common.logger.info(prot)
    if args.protocol == "clock":
        p = clock.Clock(t)
        if args.subcommand == "getrates":
            try:
                rates = p.describe_rates(args.clock_id, 0)
            except scmimodel.StatusException as e:
                common.logger.error(e)
                sys.exit(e.status)
            for rate in rates:
                common.logger.info(f"{rate / 1000000} MHz")

        if args.subcommand == "getrate":
            try:
                rate = p.rateget(args.clock_id)
            except scmimodel.StatusException as e:
                common.logger.error(e)
                sys.exit(e.status)
            common.logger.info(f"{rate / 1000000} MHz")

        if args.subcommand == "setrate":
            try:
                rate = p.rateset(args.clock_id, args.freq * 1000000)
            except scmimodel.StatusException as e:
                common.logger.error(e)
                sys.exit(e.status)
            common.logger.info(f"Frequency is sset to {args.freq} MHz")
